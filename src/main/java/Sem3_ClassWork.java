//import java.util.*;
//
//public class Sem3_ClassWork {
//    public static void main(String[] args) {
////        ArrayList list = new ArrayList();//Обявили лист. Это структура хранения данных. Динамический массив.
////        list.add(1);        //Добавили новый элемент в список типа Integer
////        list.add(.54);      //Добавили новый элемент в список типа Double
////        list.add("Привет"); //Добавили новый элемент в список типа стринг
////        list.add(new StringBuilder()); //Добавили новый элемент в список типа стрингбилдер
////        list.add(true);     //Добавили новый элемент в список булинь
////        ArrayList изначально хранит Object
////        В ArrayList можно хранить до 2млрд элементов
////        Для вытаскивания данных из такого списка нужно использовать метод:
//        if (list.get(0) instanceof String){ //Для вытаскивания данных из такого списка нужно проверить(instanceof), что 0 элемент списка list является строкой
//            list.set(0,(Object) "5"); //и в данном случае присвоили 0 элементу строку ="5"
//        //Так делать не нальзя, т.к. придется проверять каждое значение на принадлежность к каждому типу, а их десятки. А это потяря производительности и здравого смысла
//
//        //Чтобы не проверять каждый раз элемент списка на принадлежность к конкретному типу есть ОБОБЩЕНИЕ:
//        ArrayList<Integer> list1 = new ArrayList<>(); //если мы указываем тип данных, при добавлении Java проверяет тип вводимых данных на принадлежность указанному типу
//        //если тип добавляемых данных не соответствует указанному - проект не соберется.
//
//        ArrayList<Integer> list2 = new ArrayList<>();
//
//
////        for (int i = 0; i<10; i++){ //цикл фор
////            list1.add(new Random().nextInt(15)); //добавляет в конец лист1 рандомное значение от 0 до 14(15 не входит)
////            list2.add(new Random().nextInt(15));
////        }
//
////        list1.add(1); //добавляет значение в конец списка
//        //list1.add(0,17);//добавит в индекс 0 значение 17. Остальное подвинет вправо
//        //list1.addAll(list2);//добавляет все значения из list2 в конец списка list1
//        //list1.addAll(4,list2);//добавляет все значения из list2 в список list1, начинает всьавлять с 4 индекса
//
////        int a = list1.get(0); //создали переменную а, в которую записали 0 элемент списка list1
////        list1.indexOf(3); //вернёт индекс элемента, под которым в списке list1 лежит 3. Если элемента нет = вернёт -1
////        list1.indexOf(3);//может быть всё, что угодно. Строка, другие методы. Удобно.
////        list1.size();//размер списка
////        list1.clear();//очистить список
////        list1.contains(3); //вернёт true, если элемент есть в списке. false - если элемента в списке нет
////        list1.set(0,11);//изменит значение в 0 индексе на 11. Изменит, а не добавить
////        list1.remove(1);//удалить элемент из списка по индексу 1
////        list1.remove("Привет!");//удалить элемент из списка по значению. Сначала найдёт его, и удалит. Применимо скорее всего только к строкам.
//
////        System.out.println(list);
////
////
////        System.out.println(list1); //удобно выводить на экран
//
//
//        //При создании ArrayList его длинна 10 символов. При достижении этой длинны он автомтически увеличивается на половину+1 элемент.
//        //Это делает ява сама, мы за этим не следим.
//
//        //варианты пройти по всему списку
//        //1 вариант - фор
////        for (int i = 0; i < list1.size(); i++) { //самый обычный цикл фор с 0 до размера списка
////            System.out.println(list1.get(i)); //выведи на экран элемент списка с индексом i
//        }
//
//        //2 вариант - форич
////        for (int i:list1) {  //i принимает значение каждого элемента из списка list1. Внутри цикла обращаемся к нему по i
////            System.out.println(i);//вывели значение на экран
//            //удалять, изменять список в данном цикле мы не можем
////        }
////
////        //3 вариант - итератор
////        Iterator<Integer> iterator = list.iterator(); //итератор это класс, который позволяет перемещается по ссылкам на элементы итерируемых объектов. Список - итерируемы объект.
////        //итератор <какие элементы будут> название итератора = из какого элемента достаем эти элементы
////        while(iterator.hasNext()){//hasNext - проверяет, есть ли следующее значение. Если есть - true
////            int i = iterator.next();//создали переменную i, положили в неё значение следующего элемента списка
////            iterator.remove();//удаляет текущий элемент, на который указывает итератор из списка
////        }
////
////        ListIterator<Integer> listIterator = list.listIterator(list.size()-1); //всё тоже самое, только заточено именно под списки. Можно перебирать с конца, индекс size-1
////        while (listIterator.hasPrevious()){//проверяет, есть ли предыдущее значение в списке. Можно запускать с конца
////            int i = listIterator.previous();//взяли индекс предыдщуего элемента
////            listIterator.remove();
////            listIterator.nextIndex();//вернёт индекс следующего элемента, по которому можно обратиться к этому элементу для изменения/удаления
////            }
////
////
////
////        //4 вариант - встроеный форич
////        list1.forEach(n-> System.out.println(n));//вывели на экран все элементы списка list1
////
////
////
////
////        ArrayList<Integer> integers = (ArrayList<Integer>) list.subList(0,3);//сформировали список из элементов с 0 по 3 списка list.
////        //subsubList возвращает обджекты, поэтому нужно прописать ArrayList<Integer>) - чтобы сказать, что это интеджео
////
////
////        System.out.println("-".repeat(16)); //вернёт 16 раз "-"
////        list1.retainAll(list2); //оставляет внутри list1 только те элементы, которые были в list2
////        //list1.removeIf(list2); //удаляет из списка list1 только те элементы, которые были в list2
////
////        list1.sort(Comparator.naturalOrder());//отсортируй элементы списка лист1 в порядке возрастания
////        list1.sort(Comparator.reverseOrder());//отсортируй элементы списка лист1 в порядке уменьшения
////
////        list1.sort(new Comparator<Integer>() { //интеджер совпадает с тем, что указано в списке list1
////            @Override
////            public int compare(Integer o1, Integer o2) { //Integer o1 - текуший элемент, Integer o2 - следующий элемент. из о1 вычитается о2.
////                return o1-o2; //сортировка по возрастанию
////                //return o2-o1; //сортировка по убыванию
////                //сюда можно указать любое другое условие. Например:
//////                if (o1%3!=0) return 0; //считать элементы равными, если первый элемент не кратен 3. Если первый элемент не кратен 3, не важно, какой второй - они равны.
//////                if (o2%3==0) return 1; // если первый кратен 3(строка выше), и второй кратен трем(текущая строка) - то первый элемент больше(-1)
//////                return1;
////            }
////        });
//
////        Arrays.sort(new int[]{1,2,6}); //встроенная сортировка массивов.
//
////        list1.clear();
////
////        for (int i: list2) {
////            list.add(0,i);//добавить в list1 в индекс 0 значение i, которое равно каждому элементу из list2
////        }
////        System.out.println(list1);
////        System.out.println(list2);
////
////        }
//
//
//
//
//
//
//
//
////}
//
//
////}
//
//
//
//
////import java.lang.reflect.Array;
////        import java.util.ArrayList;
////        import java.util.Arrays;
////        import java.util.Comparator;
////        import java.util.Scanner;
////
////public class Main {
////    public static void main(String[] args) {
////
////        ArrayList<String> listData = new ArrayList();
////        String str = "Привет";
////        Scanner in = new Scanner(System.in);
////        while (!str.equals("Exit")) {
////
////            System.out.println("Введите ФИО, Возраст, Пол: ");
////            str = in.nextLine();
////            if (!str.equals("Exit")) {
////                String[] tmp = new String[3];
////                tmp = str.split(",");
////
////                String[] fio = new String[3];
////                fio = tmp[0].split(" ");
////                String itogStr = tmp[1]+fio[0]+" "+fio[1].toUpperCase().charAt(0)+"."
////                        +fio[2].toUpperCase().charAt(0)+"."+tmp[1]+tmp[2];
////
////                listData.add(itogStr);
////            }
////        }
////        listData.sort(Comparator.naturalOrder());
////
////        for (int i = 0; i < listData.size() ;i++){
////            System.out.println(listData.get(i).substring(3));
////        }